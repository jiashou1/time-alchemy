<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êó∂Èó¥ÁÇºÈáëÊúØ v1.4.1</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        body { font-family: 'JetBrains+Mono', monospace; background-color: #0a0a0a; color: #00ff41; min-height: 100vh; }
        .glass { background: rgba(20, 20, 20, 0.8); backdrop-filter: blur(10px); border: 1px solid #333; }
        input, select { background: #1a1a1a !important; color: #00ff41 !important; border: 1px solid #444 !important; border-radius: 4px; padding: 6px 10px; outline: none; }
        .btn-action { padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: bold; }
        .save-btn { background: #00ff41; color: #000; }
        .edit-btn { color: #666; border: 1px solid #333; font-size: 10px; padding: 2px 8px; border-radius: 4px; }
        .idea-card { border: 1px dashed #eab308; background: rgba(234, 179, 8, 0.05); }
        input[type="datetime-local"]::-webkit-calendar-picker-indicator { filter: invert(1); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        const CATEGORIES = {
            CORE: { id: 'CORE', label: '‰∫§ÊòìÁ†îÁ©∂', color: '#00ff41' },
            AI: { id: 'AI', label: 'AIÊé¢Á¥¢', color: '#0ea5e9' },
            FAMILY: { id: 'FAMILY', label: 'ÂÆ∂Â∫≠Êó∂ÂÖâ', color: '#ec4899' },
            RECREATION: { id: 'RECREATION', label: '‰ºëÈó≤Â®±‰πê', color: '#8b5cf6' },
            WASTE: { id: 'WASTE', label: 'Êó†ÊïàÊçüËÄó', color: '#ef4444' },
            RECHARGE: { id: 'RECHARGE', label: 'ËÉΩÈáèÂÖÖÁîµ', color: '#eab308' },
            IDEA: { id: 'IDEA', label: 'Âç≥Êó∂ÊÉ≥Ê≥ï', color: '#eab308' }
        };

        const App = () => {
            const [logs, setLogs] = useState(() => {
                try {
                    const saved = localStorage.getItem('timeLogs');
                    return saved ? JSON.parse(saved) : [];
                } catch (e) { return []; }
            });

            const [activeTask, setActiveTask] = useState(() => {
                try {
                    const saved = localStorage.getItem('activeTask');
                    return saved && saved !== "null" ? JSON.parse(saved) : null;
                } catch (e) { return null; }
            });

            const [config, setConfig] = useState(() => {
                try {
                    const saved = localStorage.getItem('syncConfig');
                    return saved ? JSON.parse(saved) : {token:"", gistId:""};
                } catch (e) { return {token:"", gistId:""}; }
            });
            
            const [showSettings, setShowSettings] = useState(false);
            const [syncing, setSyncing] = useState(false);
            const [feeling, setFeeling] = useState('');
            const [ideaText, setIdeaText] = useState('');
            const [currentCategory, setCurrentCategory] = useState('CORE');
            const [editingId, setEditingId] = useState(null);
            const [editDraft, setEditDraft] = useState(null);
            const [showBackfill, setShowBackfill] = useState(false);
            const [backfillData, setBackfillData] = useState({ start: "", end: "" });

            useEffect(() => {
                localStorage.setItem('timeLogs', JSON.stringify(logs));
                localStorage.setItem('activeTask', JSON.stringify(activeTask));
                localStorage.setItem('syncConfig', JSON.stringify(config));
            }, [logs, activeTask, config]);

            const sortedLogs = useMemo(() => {
                return [...logs].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
            }, [logs]);

            const toLocalISO = (isoString) => {
                if (!isoString) return "";
                const date = new Date(isoString);
                const localDate = new Date(date.getTime() - (date.getTimezoneOffset() * 60000));
                return localDate.toISOString().slice(0, 16);
            };

            const formatTimeOnly = (isoString) => {
                if(!isoString) return "--:--";
                const date = new Date(isoString);
                return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
            };

            const formatDateTime = (isoString) => {
                if(!isoString) return "--/-- --:--";
                const date = new Date(isoString);
                return `${date.getMonth()+1}/${date.getDate()} ${formatTimeOnly(isoString)}`;
            };

            const initBackfillTime = () => {
                const now = new Date();
                const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
                setBackfillData({ start: toLocalISO(oneHourAgo.toISOString()), end: toLocalISO(now.toISOString()) });
            };

            const syncData = async (mode = 'sync', silent = false) => {
                if (!config.token || !config.gistId) return;
                setSyncing(true);
                try {
                    const timestamp = Date.now();
                    const response = await fetch(`https://api.github.com/gists/${config.gistId}?_t=${timestamp}`, {
                        headers: { 'Authorization': `token ${config.token}`, 'Accept': 'application/vnd.github.v3+json' },
                        cache: 'no-store'
                    });
                    let cloudContent = [];
                    if (response.ok) {
                        const gistData = await response.json();
                        const fileContent = gistData.files['data.json']?.content;
                        if (fileContent) cloudContent = JSON.parse(fileContent);
                    }
                    let finalLogs = [];
                    if (mode === 'pull') {
                        finalLogs = cloudContent;
                    } else {
                        const uniqueMap = new Map();
                        const localData = JSON.parse(localStorage.getItem('timeLogs') || '[]');
                        [...cloudContent, ...localData].forEach(item => {
                            if (!item || !item.id) return;
                            const existing = uniqueMap.get(item.id);
                            const itemTime = item.updatedAt || item.id;
                            const existingTime = existing ? (existing.updatedAt || existing.id) : 0;
                            if (!existing || itemTime >= existingTime) uniqueMap.set(item.id, item);
                        });
                        finalLogs = Array.from(uniqueMap.values());
                    }
                    await fetch(`https://api.github.com/gists/${config.gistId}`, {
                        method: 'PATCH',
                        headers: { 'Authorization': `token ${config.token}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ files: { 'data.json': { content: JSON.stringify(finalLogs) } } })
                    });
                    setLogs(finalLogs);
                    if (!silent) alert("‰∫ëÁ´ØÂêåÊ≠•ÊàêÂäü");
                } catch (err) {
                    if (!silent) alert("ÂêåÊ≠•Â§±Ë¥•: " + err.message);
                } finally { setSyncing(false); }
            };

            const handleBackfill = (minutes = null) => {
                let start, end, duration;
                if (minutes) {
                    const now = new Date();
                    end = now.toISOString();
                    start = new Date(now.getTime() - minutes * 60 * 1000).toISOString();
                    duration = minutes;
                } else {
                    const s = new Date(backfillData.start);
                    const e = new Date(backfillData.end);
                    duration = Math.max(1, Math.round((e - s) / 1000 / 60));
                    start = s.toISOString(); end = e.toISOString();
                }
                const newLog = { id: Date.now(), category: currentCategory, startTime: start, endTime: end, duration, feeling: feeling || "", updatedAt: Date.now() };
                setLogs([newLog, ...logs]);
                setFeeling(''); setShowBackfill(false);
                setTimeout(() => syncData('sync', true), 500);
            };

            const startTask = () => {
                setActiveTask({ id: Date.now(), category: currentCategory, startTime: new Date().toISOString(), feeling, updatedAt: Date.now() });
                setFeeling('');
            };

            const stopTask = () => {
                if (!activeTask) return;
                const now = new Date();
                const completedTask = { 
                    ...activeTask, 
                    feeling: feeling || activeTask.feeling || "", // ‰øÆÂ§çÔºö‰øùÂ≠òËæìÂÖ•Ê°ÜÊñáÂ≠ó
                    endTime: now.toISOString(), 
                    duration: Math.max(1, Math.round((now - new Date(activeTask.startTime)) / 1000 / 60)), 
                    updatedAt: Date.now() 
                };
                setLogs([completedTask, ...logs]);
                setActiveTask(null);
                setFeeling(''); // ‰øÆÂ§çÔºöÈáçÁΩÆËæìÂÖ•Ê°Ü
                setTimeout(() => syncData('sync', true), 500);
            };

            const saveQuickIdea = () => {
                if (!ideaText.trim()) return;
                const newIdea = { id: Date.now(), category: 'IDEA', startTime: new Date().toISOString(), endTime: new Date().toISOString(), feeling: ideaText, duration: 0, updatedAt: Date.now() };
                setLogs([newIdea, ...logs]);
                setIdeaText('');
                setTimeout(() => syncData('sync', true), 500);
            };

            const saveEdit = () => {
                const s = new Date(editDraft.startTime);
                const e = new Date(editDraft.endTime);
                const newDuration = Math.max(1, Math.round((e - s) / 1000 / 60));
                const updatedDraft = { ...editDraft, feeling: editDraft.feeling || "", duration: editDraft.category === 'IDEA' ? 0 : newDuration, updatedAt: Date.now() };
                setLogs(logs.map(l => l.id === editingId ? updatedDraft : l));
                setEditingId(null);
                setTimeout(() => syncData('sync', true), 500);
            };

            const deleteLog = (id) => {
                if(window.confirm("Á°ÆÂÆöÂà†Èô§ÂêóÔºü")) {
                    setLogs(logs.map(l => l.id === id ? { ...l, deleted: true, updatedAt: Date.now() } : l));
                    setEditingId(null);
                    setTimeout(() => syncData('sync', true), 500);
                }
            };

            return (
                <div className="max-w-md mx-auto p-4 pb-20">
                    <header className="mb-6 pt-4 flex justify-between items-center border-b border-gray-900 pb-4">
                        <h1 className="text-xl font-bold text-[#00ff41]">Êó∂Èó¥ÁÇºÈáëÊúØ v1.4.1</h1>
                        <div className="flex items-center gap-3">
                            <span className="text-[9px] text-gray-500">{syncing ? 'ÂêåÊ≠•‰∏≠...' : 'Âú®Á∫ø'}</span>
                            <button onClick={() => setShowSettings(!showSettings)} className="text-gray-500 text-xl">‚öôÔ∏è</button>
                        </div>
                    </header>

                    {showSettings && (
                        <div className="glass p-5 rounded-xl mb-6 border-blue-500/50">
                            <div className="space-y-4">
                                <input type="password" value={config.token} onChange={e => setConfig({...config, token: e.target.value})} placeholder="GitHub Token" className="w-full text-xs" />
                                <input type="text" value={config.gistId} onChange={e => setConfig({...config, gistId: e.target.value})} placeholder="Gist ID" className="w-full text-xs" />
                                <div className="flex gap-2">
                                    <button onClick={() => syncData('pull')} className="btn-action bg-gray-800 text-white flex-1 text-[10px]">‰ªé‰∫ëÁ´ØÂêåÊ≠•Êú¨Âú∞</button>
                                    <button onClick={() => setShowSettings(false)} className="btn-action save-btn flex-1 text-[10px]">‰øùÂ≠òÈÖçÁΩÆ</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {!editingId && (
                        <div className="space-y-4 mb-8">
                            <div className="glass p-3 rounded-xl border-dashed border-[#eab308]/40 flex gap-2">
                                <input type="text" placeholder="üí° ÁÅµÊÑüÊÉ≥Ê≥ï..." value={ideaText} onChange={e => setIdeaText(e.target.value)} onKeyDown={e => e.key === 'Enter' && saveQuickIdea()} className="flex-1 text-xs" />
                                <button onClick={saveQuickIdea} className="bg-[#eab308] text-black px-3 py-1 rounded text-xs font-bold">ËÆ∞‰∏ã</button>
                            </div>

                            <div className="glass p-5 rounded-xl border-[#00ff41]/20">
                                <div className="grid grid-cols-3 gap-2 mb-4">
                                    {Object.values(CATEGORIES).filter(c => c.id !== 'IDEA').map(cat => (
                                        <button key={cat.id} onClick={() => setCurrentCategory(cat.id)} className={`text-[10px] py-2 rounded border transition-all ${currentCategory === cat.id ? 'border-[#00ff41] bg-[#00ff41]/10 text-[#00ff41]' : 'border-gray-800 text-gray-500'}`}>{cat.label}</button>
                                    ))}
                                </div>
                                <input 
                                    type="text" 
                                    placeholder={activeTask ? "Ê≠£Âú®ËÆ∞ÂΩïÔºöË°•ÂÖÖÂ§çÁõòÂøÉÂæó..." : "ËÆ∞ÂΩïÊ≠§ÂàªÂÜÖÂÆπ..."} 
                                    value={feeling} 
                                    onChange={e => setFeeling(e.target.value)} 
                                    className="w-full text-sm mb-4 bg-transparent border-b border-gray-800 pb-1" 
                                />
                                
                                {!activeTask ? (
                                    <div className="space-y-3">
                                        <button onClick={startTask} className="w-full bg-[#00ff41] text-black font-bold py-3 rounded text-sm">ÂºÄÂßãËÆ∞ÂΩï</button>
                                        <div className="flex justify-center">
                                            <button onClick={() => { setShowBackfill(!showBackfill); initBackfillTime(); }} className="text-[10px] text-gray-500 border-b border-gray-800 pb-0.5">+ Ë°•ÂΩïÂéÜÂè≤</button>
                                        </div>
                                        {showBackfill && (
                                            <div className="mt-4 pt-4 border-t border-gray-800">
                                                <div className="flex gap-2 mb-4">
                                                    {[15, 30, 60].map(m => (
                                                        <button key={m} onClick={() => handleBackfill(m)} className="flex-1 py-1.5 border border-gray-700 rounded text-[10px]">{m >= 60 ? '1h' : m+'m'}Ââç</button>
                                                    ))}
                                                </div>
                                                <div className="space-y-2 mb-4 text-[10px]">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-gray-500 w-8">ÂºÄÂßã</span>
                                                        <input type="datetime-local" value={backfillData.start} onChange={e => setBackfillData({...backfillData, start: e.target.value})} className="flex-1 py-1" />
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-gray-500 w-8">ÁªìÊùü</span>
                                                        <input type="datetime-local" value={backfillData.end} onChange={e => setBackfillData({...backfillData, end: e.target.value})} className="flex-1 py-1" />
                                                    </div>
                                                </div>
                                                <button onClick={() => handleBackfill()} className="w-full py-2 bg-gray-800 text-[#eab308] rounded text-[10px] font-bold border border-[#eab308]/30">Á°ÆËÆ§Ë°•ÂΩï</button>
                                            </div>
                                        )}
                                    </div>
                                ) : (
                                    <button onClick={stopTask} className="w-full bg-red-600 text-white font-bold py-3 rounded text-sm animate-pulse">ÂÅúÊ≠¢Âπ∂ÂêåÊ≠•</button>
                                )}
                            </div>
                        </div>
                    )}

                    <div className="space-y-3">
                        {sortedLogs.filter(l => !l.deleted).map(log => (
                            <div key={log.id} className={`glass p-4 rounded-xl ${log.category === 'IDEA' ? 'idea-card' : ''}`}>
                                {editingId === log.id ? (
                                    <div className="space-y-4">
                                        <select value={editDraft.category} onChange={e => setEditDraft({...editDraft, category: e.target.value})} className="text-xs w-full">
                                            {Object.values(CATEGORIES).map(c => <option key={c.id} value={c.id}>{c.label}</option>)}
                                        </select>
                                        <div className="space-y-2 bg-black/20 p-2 rounded border border-gray-800">
                                            <input type="datetime-local" value={toLocalISO(editDraft.startTime)} onChange={e => setEditDraft({...editDraft, startTime: new Date(e.target.value).toISOString()})} className="w-full text-[10px] bg-transparent" />
                                            <input type="datetime-local" value={toLocalISO(editDraft.endTime)} onChange={e => setEditDraft({...editDraft, endTime: new Date(e.target.value).toISOString()})} className="w-full text-[10px] bg-transparent" />
                                        </div>
                                        <input type="text" value={editDraft.feeling} onChange={e => setEditDraft({...editDraft, feeling: e.target.value})} className="w-full text-xs" placeholder="ÂÜôÁÇπ‰ªÄ‰πà..." />
                                        <div className="flex justify-between items-center">
                                            <button onClick={() => deleteLog(log.id)} className="text-[10px] text-red-500">Âà†Èô§</button>
                                            <div className="flex gap-2">
                                                <button onClick={() => setEditingId(null)} className="text-[10px] text-gray-500 px-2">ÂèñÊ∂à</button>
                                                <button onClick={saveEdit} className="text-[10px] text-[#00ff41] font-bold border border-[#00ff41] px-3 py-1 rounded">‰øùÂ≠ò‰øÆÊîπ</button>
                                            </div>
                                        </div>
                                    </div>
                                ) : (
                                    <div className="flex justify-between items-start">
                                        <div className="flex-1">
                                            <div className="flex items-center gap-2 mb-1">
                                                <span className="text-[9px] font-bold px-1 rounded" style={{backgroundColor: CATEGORIES[log.category]?.color + '22', color: CATEGORIES[log.category]?.color}}>{CATEGORIES[log.category]?.label}</span>
                                                <span className="text-[9px] text-gray-600 font-bold">
                                                    {log.category === 'IDEA' ? formatDateTime(log.startTime) : `${formatDateTime(log.startTime)} - ${formatTimeOnly(log.endTime)}`}
                                                </span>
                                            </div>
                                            <div className="text-xs text-gray-300 leading-relaxed whitespace-pre-wrap">{log.feeling}</div>
                                        </div>
                                        <div className="flex flex-col items-end gap-2 ml-4">
                                            {log.category !== 'IDEA' && <div className="text-sm font-bold text-[#00ff41]">{log.duration}m</div>}
                                            <button onClick={() => { setEditingId(log.id); setEditDraft({...log}); }} className="edit-btn">ÁºñËæë</button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
